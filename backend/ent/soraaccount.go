// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Wei-Shaw/sub2api/ent/soraaccount"
)

// SoraAccount is the model entity for the SoraAccount schema.
type SoraAccount struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// 关联 accounts 表的 ID
	AccountID int64 `json:"account_id,omitempty"`
	// AccessToken holds the value of the "access_token" field.
	AccessToken *string `json:"access_token,omitempty"`
	// SessionToken holds the value of the "session_token" field.
	SessionToken *string `json:"session_token,omitempty"`
	// RefreshToken holds the value of the "refresh_token" field.
	RefreshToken *string `json:"refresh_token,omitempty"`
	// ClientID holds the value of the "client_id" field.
	ClientID *string `json:"client_id,omitempty"`
	// Email holds the value of the "email" field.
	Email *string `json:"email,omitempty"`
	// Username holds the value of the "username" field.
	Username *string `json:"username,omitempty"`
	// Remark holds the value of the "remark" field.
	Remark *string `json:"remark,omitempty"`
	// UseCount holds the value of the "use_count" field.
	UseCount int `json:"use_count,omitempty"`
	// PlanType holds the value of the "plan_type" field.
	PlanType *string `json:"plan_type,omitempty"`
	// PlanTitle holds the value of the "plan_title" field.
	PlanTitle *string `json:"plan_title,omitempty"`
	// SubscriptionEnd holds the value of the "subscription_end" field.
	SubscriptionEnd *time.Time `json:"subscription_end,omitempty"`
	// SoraSupported holds the value of the "sora_supported" field.
	SoraSupported bool `json:"sora_supported,omitempty"`
	// SoraInviteCode holds the value of the "sora_invite_code" field.
	SoraInviteCode *string `json:"sora_invite_code,omitempty"`
	// SoraRedeemedCount holds the value of the "sora_redeemed_count" field.
	SoraRedeemedCount int `json:"sora_redeemed_count,omitempty"`
	// SoraRemainingCount holds the value of the "sora_remaining_count" field.
	SoraRemainingCount int `json:"sora_remaining_count,omitempty"`
	// SoraTotalCount holds the value of the "sora_total_count" field.
	SoraTotalCount int `json:"sora_total_count,omitempty"`
	// SoraCooldownUntil holds the value of the "sora_cooldown_until" field.
	SoraCooldownUntil *time.Time `json:"sora_cooldown_until,omitempty"`
	// CooledUntil holds the value of the "cooled_until" field.
	CooledUntil *time.Time `json:"cooled_until,omitempty"`
	// ImageEnabled holds the value of the "image_enabled" field.
	ImageEnabled bool `json:"image_enabled,omitempty"`
	// VideoEnabled holds the value of the "video_enabled" field.
	VideoEnabled bool `json:"video_enabled,omitempty"`
	// ImageConcurrency holds the value of the "image_concurrency" field.
	ImageConcurrency int `json:"image_concurrency,omitempty"`
	// VideoConcurrency holds the value of the "video_concurrency" field.
	VideoConcurrency int `json:"video_concurrency,omitempty"`
	// IsExpired holds the value of the "is_expired" field.
	IsExpired    bool `json:"is_expired,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*SoraAccount) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case soraaccount.FieldSoraSupported, soraaccount.FieldImageEnabled, soraaccount.FieldVideoEnabled, soraaccount.FieldIsExpired:
			values[i] = new(sql.NullBool)
		case soraaccount.FieldID, soraaccount.FieldAccountID, soraaccount.FieldUseCount, soraaccount.FieldSoraRedeemedCount, soraaccount.FieldSoraRemainingCount, soraaccount.FieldSoraTotalCount, soraaccount.FieldImageConcurrency, soraaccount.FieldVideoConcurrency:
			values[i] = new(sql.NullInt64)
		case soraaccount.FieldAccessToken, soraaccount.FieldSessionToken, soraaccount.FieldRefreshToken, soraaccount.FieldClientID, soraaccount.FieldEmail, soraaccount.FieldUsername, soraaccount.FieldRemark, soraaccount.FieldPlanType, soraaccount.FieldPlanTitle, soraaccount.FieldSoraInviteCode:
			values[i] = new(sql.NullString)
		case soraaccount.FieldCreatedAt, soraaccount.FieldUpdatedAt, soraaccount.FieldSubscriptionEnd, soraaccount.FieldSoraCooldownUntil, soraaccount.FieldCooledUntil:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the SoraAccount fields.
func (_m *SoraAccount) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case soraaccount.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			_m.ID = int64(value.Int64)
		case soraaccount.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case soraaccount.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case soraaccount.FieldAccountID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field account_id", values[i])
			} else if value.Valid {
				_m.AccountID = value.Int64
			}
		case soraaccount.FieldAccessToken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field access_token", values[i])
			} else if value.Valid {
				_m.AccessToken = new(string)
				*_m.AccessToken = value.String
			}
		case soraaccount.FieldSessionToken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field session_token", values[i])
			} else if value.Valid {
				_m.SessionToken = new(string)
				*_m.SessionToken = value.String
			}
		case soraaccount.FieldRefreshToken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refresh_token", values[i])
			} else if value.Valid {
				_m.RefreshToken = new(string)
				*_m.RefreshToken = value.String
			}
		case soraaccount.FieldClientID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field client_id", values[i])
			} else if value.Valid {
				_m.ClientID = new(string)
				*_m.ClientID = value.String
			}
		case soraaccount.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field email", values[i])
			} else if value.Valid {
				_m.Email = new(string)
				*_m.Email = value.String
			}
		case soraaccount.FieldUsername:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field username", values[i])
			} else if value.Valid {
				_m.Username = new(string)
				*_m.Username = value.String
			}
		case soraaccount.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				_m.Remark = new(string)
				*_m.Remark = value.String
			}
		case soraaccount.FieldUseCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field use_count", values[i])
			} else if value.Valid {
				_m.UseCount = int(value.Int64)
			}
		case soraaccount.FieldPlanType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field plan_type", values[i])
			} else if value.Valid {
				_m.PlanType = new(string)
				*_m.PlanType = value.String
			}
		case soraaccount.FieldPlanTitle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field plan_title", values[i])
			} else if value.Valid {
				_m.PlanTitle = new(string)
				*_m.PlanTitle = value.String
			}
		case soraaccount.FieldSubscriptionEnd:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field subscription_end", values[i])
			} else if value.Valid {
				_m.SubscriptionEnd = new(time.Time)
				*_m.SubscriptionEnd = value.Time
			}
		case soraaccount.FieldSoraSupported:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field sora_supported", values[i])
			} else if value.Valid {
				_m.SoraSupported = value.Bool
			}
		case soraaccount.FieldSoraInviteCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sora_invite_code", values[i])
			} else if value.Valid {
				_m.SoraInviteCode = new(string)
				*_m.SoraInviteCode = value.String
			}
		case soraaccount.FieldSoraRedeemedCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sora_redeemed_count", values[i])
			} else if value.Valid {
				_m.SoraRedeemedCount = int(value.Int64)
			}
		case soraaccount.FieldSoraRemainingCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sora_remaining_count", values[i])
			} else if value.Valid {
				_m.SoraRemainingCount = int(value.Int64)
			}
		case soraaccount.FieldSoraTotalCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sora_total_count", values[i])
			} else if value.Valid {
				_m.SoraTotalCount = int(value.Int64)
			}
		case soraaccount.FieldSoraCooldownUntil:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field sora_cooldown_until", values[i])
			} else if value.Valid {
				_m.SoraCooldownUntil = new(time.Time)
				*_m.SoraCooldownUntil = value.Time
			}
		case soraaccount.FieldCooledUntil:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field cooled_until", values[i])
			} else if value.Valid {
				_m.CooledUntil = new(time.Time)
				*_m.CooledUntil = value.Time
			}
		case soraaccount.FieldImageEnabled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field image_enabled", values[i])
			} else if value.Valid {
				_m.ImageEnabled = value.Bool
			}
		case soraaccount.FieldVideoEnabled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field video_enabled", values[i])
			} else if value.Valid {
				_m.VideoEnabled = value.Bool
			}
		case soraaccount.FieldImageConcurrency:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field image_concurrency", values[i])
			} else if value.Valid {
				_m.ImageConcurrency = int(value.Int64)
			}
		case soraaccount.FieldVideoConcurrency:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field video_concurrency", values[i])
			} else if value.Valid {
				_m.VideoConcurrency = int(value.Int64)
			}
		case soraaccount.FieldIsExpired:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_expired", values[i])
			} else if value.Valid {
				_m.IsExpired = value.Bool
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the SoraAccount.
// This includes values selected through modifiers, order, etc.
func (_m *SoraAccount) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// Update returns a builder for updating this SoraAccount.
// Note that you need to call SoraAccount.Unwrap() before calling this method if this SoraAccount
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *SoraAccount) Update() *SoraAccountUpdateOne {
	return NewSoraAccountClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the SoraAccount entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *SoraAccount) Unwrap() *SoraAccount {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: SoraAccount is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *SoraAccount) String() string {
	var builder strings.Builder
	builder.WriteString("SoraAccount(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("account_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.AccountID))
	builder.WriteString(", ")
	if v := _m.AccessToken; v != nil {
		builder.WriteString("access_token=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.SessionToken; v != nil {
		builder.WriteString("session_token=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.RefreshToken; v != nil {
		builder.WriteString("refresh_token=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.ClientID; v != nil {
		builder.WriteString("client_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.Email; v != nil {
		builder.WriteString("email=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.Username; v != nil {
		builder.WriteString("username=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.Remark; v != nil {
		builder.WriteString("remark=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("use_count=")
	builder.WriteString(fmt.Sprintf("%v", _m.UseCount))
	builder.WriteString(", ")
	if v := _m.PlanType; v != nil {
		builder.WriteString("plan_type=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.PlanTitle; v != nil {
		builder.WriteString("plan_title=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.SubscriptionEnd; v != nil {
		builder.WriteString("subscription_end=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("sora_supported=")
	builder.WriteString(fmt.Sprintf("%v", _m.SoraSupported))
	builder.WriteString(", ")
	if v := _m.SoraInviteCode; v != nil {
		builder.WriteString("sora_invite_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("sora_redeemed_count=")
	builder.WriteString(fmt.Sprintf("%v", _m.SoraRedeemedCount))
	builder.WriteString(", ")
	builder.WriteString("sora_remaining_count=")
	builder.WriteString(fmt.Sprintf("%v", _m.SoraRemainingCount))
	builder.WriteString(", ")
	builder.WriteString("sora_total_count=")
	builder.WriteString(fmt.Sprintf("%v", _m.SoraTotalCount))
	builder.WriteString(", ")
	if v := _m.SoraCooldownUntil; v != nil {
		builder.WriteString("sora_cooldown_until=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.CooledUntil; v != nil {
		builder.WriteString("cooled_until=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("image_enabled=")
	builder.WriteString(fmt.Sprintf("%v", _m.ImageEnabled))
	builder.WriteString(", ")
	builder.WriteString("video_enabled=")
	builder.WriteString(fmt.Sprintf("%v", _m.VideoEnabled))
	builder.WriteString(", ")
	builder.WriteString("image_concurrency=")
	builder.WriteString(fmt.Sprintf("%v", _m.ImageConcurrency))
	builder.WriteString(", ")
	builder.WriteString("video_concurrency=")
	builder.WriteString(fmt.Sprintf("%v", _m.VideoConcurrency))
	builder.WriteString(", ")
	builder.WriteString("is_expired=")
	builder.WriteString(fmt.Sprintf("%v", _m.IsExpired))
	builder.WriteByte(')')
	return builder.String()
}

// SoraAccounts is a parsable slice of SoraAccount.
type SoraAccounts []*SoraAccount
